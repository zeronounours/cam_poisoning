// Common configuration file (autogenerated)
#include <config.h>

// System headers
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <argp.h>
#include <string.h>
#include <signal.h>
#include <errno.h>

#include <sys/stat.h>

// network
#include <sys/socket.h>
#include <sys/un.h>

#include <logger.h>


/*******************
 * Argument parser *
 *******************/
#define NB_ARGS 0
const char *argp_program_version = PACKAGE_STRING;
const char *argp_program_bug_address = PACKAGE_BUGREPORT;
static char doc[] =
"A client tester for the CAM poisoning application.\n"
"Just launch this application before starting to poison. It only resend "
"intercepted packets without modifying them. Intercepted packets can easily "
"be monitored with packet dissector applications like Wireshark.";

static char args_doc[] = "";
static struct argp_option options[] = {
	{ "open",	'o',	0,			0,	"Do not relay any frame"},
	{ "verbose",	'v',	0,			0,	"Produce verbose output"},
	{ 0 }
};

struct arguments {
	int verbose;
	int opened;
};

/*
 * argp parser
 */
static error_t parse_opt(int key, char *arg, struct argp_state *state) {
	struct arguments *arguments = state->input;
	switch (key) {
		case 'v':
			arguments->verbose = 1;
			break;

		case 'o':
			arguments->opened= 1;
			break;

		case ARGP_KEY_ARG:
			if (state->arg_num >= NB_ARGS)
				// Too many arguments
				argp_usage(state);
			break;

		case ARGP_KEY_END:
			// check argument number
			if (state->arg_num < NB_ARGS)
				/* Not enough arguments. */
				argp_usage(state);
			break;

		default:
			return ARGP_ERR_UNKNOWN;
	}
	return 0;
}

static struct argp argp = { options, parse_opt, args_doc, doc, 0, 0, 0 };
static void (*prev_handler)(int);
static struct sockaddr_un svaddr;

#define MAX_PKT_SIZE 1500
#define ETH_HDR_SIZE 14
#define MAC_ARG(x) (x)[0],(x)[1],(x)[2],(x)[3],(x)[4],(x)[5]

#define VAR_DIR_PATH	"/var/run/" PACKAGE_NAME
#define SOCKET_PATH		VAR_DIR_PATH "/tester.sock"

void delete_socket_file() {
	if (unlink(svaddr.sun_path) == -1) {
		perror("Failed to delete the socket file");
	}
}

void sigint_handler(int sig) {
	delete_socket_file();

	// restore the previous handler
	signal(sig, prev_handler);
	raise(sig);
}

/********
 * Main *
 ********/
int main(int argc, char *argv[]) {
	// parse the commandline arguments
	struct arguments args;
	memset(&args, 0, sizeof(struct arguments));

	// parse cmdline arguments
	argp_parse(&argp, argc, argv, 0, 0, &args);

	// Ensure the base directory for the socket path exists
	struct stat st = {0};
	if (stat(VAR_DIR_PATH, &st) == -1) {
		if (errno == ENOENT) {
			if (mkdir(VAR_DIR_PATH, 0755) == -1) {
				perror("Failed to create socket directory");
				exit(1);
			}
		} else {
			perror("Failed to stat socket directory");
			exit(1);
		}
	} else {
		// Ensure the the socket is deleted if it exists
		if (stat(SOCKET_PATH, &st) == -1) {
			// The only accepted error is ENOENT (i.e. file doesn't exist)
			if (errno != ENOENT) {
				perror("Failed to stat the socket file");
				exit(1);
			}
		} else {
			// File exists => need to delete
			if (unlink(SOCKET_PATH) == -1) {
				perror("Failed to delete the socket file");
			}
		}
	}

	// open the IPC socket
	int ipc;
	unsigned char buf[MAX_PKT_SIZE];
	ssize_t buflen;
	unsigned long pkt_count = 0;
	struct sockaddr_un claddr = {0};
	socklen_t claddr_l;

	// create the socket and connect it to the file
	if ( (ipc = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
		perror("Cannot open UNIX socket");
		exit(1);
	}

	memset(&svaddr, 0, sizeof(struct sockaddr_un));
	svaddr.sun_family = AF_UNIX;
	strncpy(svaddr.sun_path, SOCKET_PATH, sizeof(svaddr.sun_path) - 1);


	if (bind(ipc, (struct sockaddr*) &svaddr, sizeof(svaddr)) == -1) {
		perror("Cannot bind UNIX socket");
		exit(1);
	}
	// print a message to notify of the socket path
	printf("The IPC socket has been opened here: %s\n", SOCKET_PATH);

	// register a signal handler on SIGINT to unlink the socket file
	prev_handler = signal(SIGINT, sigint_handler);

	printf("Wait for incoming packets\n");
	for (;;) {
		// Read and directly retransmit all packets
		// Read
		claddr_l = sizeof(claddr);
		buflen = recvfrom(ipc, buf, MAX_PKT_SIZE, 0,
				(struct sockaddr *)&claddr, &claddr_l);
		if (buflen == -1) {
			// case error
			if (!args.verbose)
				printf("\n");
			perror("Error while reading IPC");
			delete_socket_file();
			exit(1);
		} else if (buflen >= ETH_HDR_SIZE) {
			// case a packet was received

			// print info about the received packet
			if (args.verbose) {
				printf("Received frame #%i: "
						"%02x:%02x:%02x:%02x:%02x:%02x -> "
						"%02x:%02x:%02x:%02x:%02x:%02x\n", ++pkt_count,
						MAC_ARG(&buf[6]), MAC_ARG(buf));
			} else {
				printf("\rReceived frame #%i", ++pkt_count);
				fflush(stdout);
			}

			// Send the packet back
			if (!args.opened && sendto(ipc, buf, buflen, 0,
						(struct sockaddr *)&claddr, claddr_l) == -1) {
				if (!args.verbose)
					printf("\n");
				perror("Error while writing IPC");
				delete_socket_file();
				exit(1);
			}
		}
	}

	// should not be reached
	// close the IPC socket
	close(ipc);

	// delete the socket file
	delete_socket_file();

	return 0;
}
